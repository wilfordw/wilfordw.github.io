<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaScript 数组增删改]]></title>
      <url>%2F2017%2F04%2F21%2FJavaScript-%E6%95%B0%E7%BB%84%E5%A2%9E%E5%88%A0%E6%94%B9%2F</url>
      <content type="text"><![CDATA[#push and pop 12345678let arr = [1, 2, 3].push(4, 5) // [1, 2, 3, 4, 5]arr.pop() //5arr.pop() //4arr.pop() //3arr.pop() //2arr.pop() //1arr.pop() //undefined #unshift and shift 123let arr = [1, 2, 3].shift(4, 5) // [4, 5, 1, 2, 3]arr.unshift() // 4 #join 1let arr = ['hello', 'world'].join('-') // 'hello-world' #slice 123let arr = [1, 2, 3]arr.slice(1) // [2, 3] 获取第一位到最后一个元素arr.slice(1, 1) // [1] 获取第一位开始数量为1个元素 #splice 123let arr = [1, 2, 3]arr.splice(1, 0, 4, 5) // [1, 4, 5, 2, 3] 在index为1的位置插入4 5两个元素arr.splice(1, 1, 4, 5) // [1, 4, 5, 3] 把index为1位置开始1个元素删除再插入元素 #contat 1let arr = [0, 1, 2].contat(3, 4, 5) // [0, 1, 2, 3, 4, 5] #参考资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript6 学习笔记七]]></title>
      <url>%2F2017%2F04%2F21%2FECMAScript6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83%2F</url>
      <content type="text"><![CDATA[#参考资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript6 学习笔记六]]></title>
      <url>%2F2017%2F04%2F21%2FECMAScript6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%2F</url>
      <content type="text"><![CDATA[#Class #声明使用 12345678910class Person&#123; constructor(name) &#123; this.name = name &#125; sayName() &#123; console.log(this.name) &#125;&#125;let person = new Person('张三')person.sayName() //张三 #继承 123456789class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y) // 调用父类的constructor(x, y) this.color = color &#125; toString() &#123; return this.color + ' ' + super.toString() // 调用父类的toString &#125;&#125; #静态私有 123456class Point &#123; static a static method() &#123;&#125; #x = 0 #sum() &#123;&#125;&#125; #修饰器 1234567891011121314151617181920@decoratorclass A &#123;&#125;// 等同于class A &#123;&#125;A = decorator(A) || A// decorator 可以带参数function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable &#125;&#125;@testable(true)class MyTestableClass &#123;&#125;MyTestableClass.isTestable //true@testable(false)class MyClass &#123;&#125;MyClass.isTestable //false #core-decorators.js core-decorators.js是一个第三方模块，提供了几个常见的修饰器 1234567import &#123; autobind, readonly, override, deprecate, suppressWarnings &#125; from 'core-decorators'@autobind //绑定方法的this对象@readonly@override //检测继承方法是否正确@deprecate //弃用的方法@suppressWarnings //抑制decorator修饰器导致的警告 #Trait 1234567891011121314151617181920212223242526import &#123; traits &#125; from 'traits-decorator'class TFoo &#123; foo() &#123; console.log('foo') &#125;&#125;class TBar = &#123; foo() &#123; console.log('foo') &#125; bar() &#123; console.log('bar') &#125;&#125;@traits(TFoo, TBar)class MyClass &#123;&#125;let obj = new MyClass()obj.foo()obj.bar()@traits(TFoo::alias(&#123;foo: 'aliasFoo'&#125;), TBar::excludes('foo'))class MyClass1 &#123;&#125;let obj1 = new MyClass1()obj1.aliasFoo()obj1.bar()//as 写法@traits(TExample::as(&#123;excludes:['foo', 'bar'], alias: &#123;baz: 'exampleBaz'&#125;&#125;))class MyClass #参考资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript6 学习笔记五]]></title>
      <url>%2F2017%2F04%2F20%2FECMAScript6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94%2F</url>
      <content type="text"><![CDATA[#Promise #基本形态 12345678910//基本建议形态new Promise(function (resolve, reject) &#123; if(...)&#123;// 成功 resolve("success") &#125;else&#123; reject("fail") &#125;&#125;).then(result =&gt; console.log(result)).catch(error =&gt; console.log(error)) #链式调用 then方法返回的是新的Promise实例，因此可以链式写法 1234new Promise(function(resolve, reject)&#123;...&#125;).then(() =&gt; doSomething).then(() =&gt; doSomething).then(() =&gt; doSomething) #Promise.all 全完成则完成，一个被拒绝全部被拒绝 1234567891011var p = Promise.all([p1, p2, p3])var promise = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON("/post/" + id + ".json")&#125;)Promise.all(promise).then(function (posts) &#123; //...n&#125;).catch(function(reason)&#123; //...&#125;) #Promise.race 第一个完成的改变状态 12345678const p = Promise.race([ fetch('/resource-that-my-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject( new Error('request timeout')), 500) &#125;)])p.then(response =&gt; console.log(response))p.catch(error =&gt; console.log(error)) #Promise.resolve 现有对象转化为Promise实例 123456789101112131415Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo'))// thenablelet thenable = &#123; then: function(resolve, reject) &#123; resolve(42) &#125;&#125;let p1 = Promise.resolve(thenable)p1.then(function(value) &#123; console.log(value) //42&#125;) #Promise.reject 123var p = Promise.reject('出错我')p.catch(e =&gt; console.log(e)) #自己附加方法 #Promise.done 12345678910Promise.prototype.done = function (onFulfilled, onRejected) &#123; this.then(onFulfilled, onRejected) .catch(function (reason) &#123; // 输出一个全局错误 setTimeout(() =&gt; &#123;throw reason&#125;, 0) &#125;)&#125;// 使用asyncFunc().then(f1).catch(r1).then(f2).done() #Promise.finally 123456789101112Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resovle(callback()).then(() =&gt; value), reason = P.resovle(callback()).then(() =&gt; &#123; throw reason &#125;) )&#125;// 使用server.listen(0).then(function()&#123;&#125;).finally(server.stop) #Iterator ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性上，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为可遍历 12345678910111213141516171819const obj = &#123; [Symbol.iterator]: function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125; &#125; &#125; &#125;&#125;// 数组类结构直接引用数组的Iterator接口NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator]//或者NodeList.prototype[Symbol.iterator] = [][Symbol.iterator][...document.querySelectorAll('div')] //可以执行了 #Generator 123456789101112function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123;i = -1&#125; &#125;&#125;var g = f()g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123;value: 0, done, false &#125; 参数传值给reset #异步编程 co 模块是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行。 下面是一个 Generator 函数，用于依次读取两个文件。 1234567891011121314var gen = function* () &#123; var f1 = yield readFile('/etc/fstab') var f2 = yield readFile('/etc/shells') console.log(f1.toString()) console.log(f2.toString())&#125;// co 模块可以让你不用编写 Generator 函数的执行器。var co = require('co')co(gen).then(function ()&#123; console.log('Generator 函数执行完成')&#125;) #参考资料 ECMAScript6 入门]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript6 学习笔记四]]></title>
      <url>%2F2017%2F04%2F20%2FECMAScript6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%2F</url>
      <content type="text"><![CDATA[#Proxy Proxy可以修改Reflect对象的所有方法，它们的方法是一一对应的，Proxy对象可以方便地调用对应的Reflect方法，完成默认行为 123456var obj = new Proxy(&#123;&#125;,&#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;`) return Reflect.get(target, key, receiver) &#125;&#125;) #Reflect Reflect是ES6新加的API，它把原来Object上的方法整合进来，Object的这些方法逐步会被弃用 1234567891011121314151617181920212223242526272829Reflect.get(target, key, receiver) //调用target对象的getter，接收者是receiver对象，也就是this对应的是receiverReflect.set(target, key, value, receiver) // 调用target对象的setter，接收者是receiver对象Reflect.has(obj, name) //name in obj 里的in 运算Reflect.deleteProperty(obj, name) //delete obj[name]Reflect.constructor(target, args) // new target(...args)Reflect.getPrototypeOf(obj) // Object.getPrototypeOf(obj)const myObj = new FancyThing()Reflect.getPrototypeOf(myObj) === FancyThing.prototypeReflect.setProtoType(obj, newProto) //Object.setProtoType(obj)Reflect.setProtoType(myObj, OtherThing.prototype)Reflect.apply(func, thisArg, args) //Function.prototype.apply.call(func, thisArg, args)const youngest = Reflect.apply(Math.min, Math, ages)Reflect.defineProperty(target, propertyKey, attributes) //Object.definePropertyReflect.defineProperty(MyDate, 'now', &#123; value: () =&gt; new Date.now()&#125;)Reflect.getOwnPropertyDescriptor(target, propertyKey) //Object.getOwnPropertyDescriptorReflect.isExtensible(obj) //Object.isExtensibleReflect.preventExtensions(target) //Object.preventExtensionsReflect.ownKeys(target) //返回对象所有属性 包括Symbol #实例 #Proxy实现Web服务的客户端 12345678//Web服务的客户端function createWebService(baseUrl) &#123; return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return () =&gt; httpGet(baseUrl + '/' + propKey) &#125; &#125;)&#125; #Proxy实现观察者模式 1234567891011const queuedObservers = new Set()const observe = fn =&gt; queuedObservers.add(fn)const obervable = obj =&gt; new Proxy(obj, &#123;set&#125;)function set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver) queuedObservers.forEach(observer =&gt; observer()) return result&#125; #参考资料 ECMAScript6 入门]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript6 学习笔记三]]></title>
      <url>%2F2017%2F04%2F19%2FECMAScript6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%2F</url>
      <content type="text"><![CDATA[#函数 #函数默认值 1234function log(x, y = 'World') &#123; console.log(x, y)&#125; #rest参数 12345678//arguments变量写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort()&#125;//rest参数写法const sortNumbers = (...numbers) =&gt; numbers.sort() #扩展运算符(rest逆运算) 1234567891011121314151617181920212223242526272829function push(array, ...items) &#123; array.push(...items)&#125;// ES5写法Math.max.apply(null, [14, 3, 77])// ES6写法Math.max(...[14, 3, 77])var arr1 = [0, 1, 2]var arr2 = [3, 4, 5]// ES5写法Array.prototype.push.apply(arr1, arr2)// ES6写法arr1.push(...arr2)// 与解构赋值结合[a, ...rest] = list// 正确识别32位的Unicode字符let str = 'x\uD83D\uDE80y'str.split('').reverse().join('') // y\uDE80\uD83Dx 字符串reverse操作不正确[...str].reverse().join('') // y\uD83D\uDE80x #函数名 1234567const bar = function bar() &#123;&#125;bar.name // bar(new Function).name // anonymousfoo.bind(&#123;&#125;),name //bound foo #箭头函数 1234567891011// this对象，指向定义时所在的对象，不是使用时所在的对象// 不能使用new arguments yieldfunction foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id) &#125;, 100)&#125;var id = 21foo.call(&#123; id: 42 &#125;)//id: 42 #尾调用优化 12345678910111213141516function f() &#123; let m = 1 let n = 2 return g(m + m)&#125;f()// 等同于function f() &#123; return g(3)&#125;f()// 等同于g(3)// 只保留内部函数的调用帧，如果所有函数都是尾调用，完全可以做到每次执行时，调用帧只有一项，大大节省内存 经典应用 fibonacci递归 123456789101112131415161718function fibonacci (n) &#123; if(n &lt;= 1) &#123; return 1 &#125; return fibonacci(n - 1) + fibonacci(n - 2)&#125;fibonacci(10) //89// fibonacci(100)// fibonacci(500)// 堆栈溢出function fibonacci2(n, ac1 = 1, ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return act2&#125; return fibonacci2(n - 1, ac1, ac2 + ac1)&#125;fibonacci2(100)fibonacci2(1000)fibonacci2(10000) // Infinity #绑定this 123456789101112foo::bar// 等同于bar.bind(foo)foo::bar(...arguments)// 等同于bar.apply(foo, arguments)var method = obj::obj.foo// 等同于var method = ::obj.foo #对象 #对象属性方法简写 12345678910111213141516171819var foo = 'bar'var baz = &#123;foo&#125;baz //&#123;foo: 'bar'&#125;// 等同于var bar = &#123;foo: foo&#125;var o = &#123; method() &#123; return "Hello" &#125;&#125;// 等同于var o = &#123; method: function() &#123; return "Hello" &#125;&#125; #Object.is 12345+0 === -0 //trueNaN === NaN //falseObject.is(+0, -0) //falseObject.is(NaN, NaN) //true #Object.assign 123456789101112131415161718var target = &#123;a: 1, b: 1&#125;var source1 = &#123;b: 2, c: 2&#125;var source2 = &#123;c: 3&#125;Object.assign(target, source1, source2)target // &#123;a:1, b:2, c:3&#125;// 为对象添加属性class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;) &#125;&#125;// 克隆对象var clone = Object.assign(&#123;&#125;, origin)// assign方法会忽略enumerable为false的属性，只拷贝自身的可枚举对象 #属性遍历 123456789for...in //循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）Object.keys(obj) //返回数组，包含自身（不含继承的）所有可枚举属性（不含Symbol属性）Object.getOwnPropertyNames(obj) //返回一个数组， 包含对象自身的所有属性（不含Symbol属性，但包含不可枚举属性）Object.getOwnPropertySymbols(obj) //返回一个数组，包含对象自身的所有Symbol属性Reflect.ownKeys(obj) //返回一个数组，包含对象自身的所有属性，不管属性名是Symbol或字符串，也不管是否可枚举 #NULL传到运算符 123456789const firstName = message?.body?.user?.firstName || 'default'//只要其中一个?.返回null或者undefined,就直接返回undefined//用法obj?.prop// 读取对象属性obj?.[expr] // 同上func?.(...args) //函数或对象方法的调用new C?.(...args) // 构造函数的调用 #Symbol #作为函数名 1234567891011121314var mySymbol = Symbol()var a = &#123;&#125;a[mySymbol] = 'Hello!'var a = &#123; [mySymbol]: 'Hello!'&#125;var a = &#123;&#125;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;)a[mySymbol] // "Hello!" #Symbol.for() Symbol.keyFor() 12345var s1 = Symbol.for('foo')var s2 = Symbol.for('foo')s1 === s2 //true #内置Symbol #Symbol.hasInstance 12345678class MyClass &#123; [Symbol.hasInstance](foo) &#123; return foo instanceof Array &#125;&#125;[1, 2, 3] instanceof new MyClass() //true #Symbol.iterator 123456789var myIterable = &#123;&#125;myIterable[Symbol.iterator] = function* () &#123; yield 1 yield 2 yield 3&#125;[...myIterable] // [1, 2, 3] #Set Set的遍历顺序就是插入顺序。可以用来保存函数调用列表，保证调用按照添加顺序 123456789101112131415161718192021// 去除数组的重复成员[...net Set(array)]let set = new Set(['red', 'green', 'blue'])// 遍历方法set.keys()set.values()set.entries()set.forEach()let a = new Set([1, 2, 3])let b = new Set([4, 3, 2])//并集let union = new Set([...a, ...b])//交集let intersect = new Set([...a].filter(x =&gt; b.has(x)))// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x))) #Map 123456789const m = new Map()const o = &#123;p: 'Hello World'&#125;m.set(o, 'content')m.get(o) // contentm.has(o) // truem.delete(o) // truem.has(o) //false #参考资料 ECMAScript6 入门]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript6 学习笔记 二]]></title>
      <url>%2F2017%2F04%2F19%2FECMAScript6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[#数值 #二进制和十六进制 1234560b111110111 = 503 //true 二进制0o767 = 503 // true 十六进制Number('0b111') // 7Number('0o10') // 8 #isFinite和isNaN 123456Number.isFinite(Infinity) // falseNumber.isFinite(15) // trueNumber.isFinite('15') //falseNumber.isNaN(NaN) // true #极小常量EPSILON 12Number.EPSILON // 2.220446049250313e-16 #MAX_SAFE_INTEGER和MIN_SAFE_INTEGER 123Number.MAX_SAFE_INTEGER === Math.pow(2. 53) - 1 // trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER #去除小数部分 12Math.trunc(4.1) // 4 #立方根 123Math.cbrt(-1) // -1Math.cbrt('8') // 2 #大位数乘法 123(0x7fffffff * 0x7fffffff) | 0 // 0Math.imul(0x7fffffff, 0x7fffffff) // 1 #平方和的平方根 1234Math.hypot(3, 4) // 5Math.hypot(3, 4, 5) // 7.07106781186546755 #数组 #Array.from() 1234567891011121314151617181920212223let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法var arr2 = Array.from(arrayLike); // ['a', 'b', 'c']// Array.from的第二个参数Array.from(arrayLike, x =&gt; x * x)// 等同于Array.from(arrayLike).map(x =&gt; x * x)// 应用Array.from([1, , 2, , 3], (n) =&gt; n || 0) // [1, 0, 2, 0, 3]// map函数里用到this关键字，可以传入Array.from的第三个参数， 用来绑定this #find 1234567[1, 4, -5, 10].find((n) =&gt; n &lt; 0) // -5// value 当前值 index 位置 arr 原数组[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9&#125;) //10 #fill 1234567['a', 'b', 'c'].fill(7) // [7, 7, 7]new Array(3).fill(7) // [7, 7, 7]// 第二个参数 起始位置 第三个参数 结束位置['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] #entries(), keys()和valus() 123456789101112131415161718for (let index of ['a', 'b'].keys()) &#123; console.log(index)&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem)&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem)&#125;// 0 "a"// 1 "b" #includes() 123456[1, 2, 3].includes(2) //true[1, 2, NaN].includes(NaN) //true[1, 2, 3].includes(3, 3) //false[1, 2, 3].includes(3, -1) // true #in 判断某位是否有值 1230 in [undefined, undefined, undefined] //true0 in [, , ,] // false #参考资料 ECMAScript6 入门]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript6 学习笔记 一]]></title>
      <url>%2F2017%2F04%2F17%2FECMAScript6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[#变量的解构赋值 #使用方法 1234567891011121314151617181920212223242526// 模式化匹配 匹配不到赋值undefinedlet [a, b, c] = [1, 2, 3]let [foo, [[bar], baz]] = [1, [[2], 3]]let [ , , third] = ['one', 'two', 'three']let [head, ...tail] = [1, 2, 3, 4]// 默认值 匹配到undeined使用默认值let [foo = true] = []// 默认值可以用表达式function f() &#123;&#125;let [x = f()] = [1]// 对象键值匹配let &#123;foo, bar&#125; = &#123;foo: 1, bar: 2&#125;let &#123;foo: f, bar: b&#125; = &#123;foo: 1, bar: 2&#125;//这里()是必须的，没有的话&#123;&#125;会被解析成代码块let foo(&#123;foo&#125; = &#123;foo: 1&#125;) #应用 #交换变量 12345let x = 1let y = 2[x, y] = [y, x] #JSON解析 123456789101112let jsonData = &#123; id: 42, status: "OK", data: [88,10]&#125;let &#123; id , status, data: number&#125; = jsonDataconsole.log(id, status, number)//42, "OK", [88,10] #函数参数默认值 123456789101112jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, globa = true, // ... more config&#125;) &#123; // ... do something&#125; #遍历Map 12345678let map = new Map()map.set('first', 'hello')map.set('second', 'world')for (let [key, value] of map) &#123; console.log(key + " is " + value)&#125; #字符串扩展 #补全字符串 123'12'.padStart(10, 'YYYY-MM-DD') //'YYYY-MM-12''12'.padEnd(10,'YYYY-MM-DD') //'12YY-MM-DD' #字符串模板 12345678910111213141516let name = "Bob"let time = "today"'Hello $&#123;name&#125;, how are you $&#123;time&#125;?'// 执行模板let str = 'return ' + '`Hello $&#123;name&#125;!`'let func = new Function('name', str)func('Jack') //"Hello Jack!"let str = '(name) =&gt; `Hello $&#123;name&#125;!`'let func = eval.call(null,str);func('Jack') //"Hello Jack!" #标签模板 1234567let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123;a * b&#125;`// 等同于tag(['Hello ', ' world', ''], 15, 50) #参考资料 ECMAScript6 入门]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJs学习笔记]]></title>
      <url>%2F2017%2F04%2F16%2FNodeJs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[#入口模块 package.json 1234&#123; "main": "xxx.js" //定义入口模块&#125; #通常项目包含 123456789- project + bin # 命令行相关代码 + doc # 文档 + lib # api相关代码 + node_modules # 存放三方包 + tests # 测试用例 package.json # 元数据文件 README.md # 说明文件 #NPM发布代码 1234npm adduser #注册账号npm publish #发布代码 #BOM移除 12345678910function readText(pathname) &#123; var bin = fs.readFileSync(pathname) if (bin[0] === 0xEF &amp;&amp; bin[1] === 0xBB &amp;&amp; bin[2] === 0xBF) &#123; bin = bin.slice(3) &#125; return bin.toString('utf-8');&#125; #http请求 #http 服务器 1234567var http = require('http') # 引用http模块http.createServer(function (request, response) &#123; response.writeHead(200, &#123; 'Content-Type': 'text-plain'&#125;) # 写入http头 response.end('Hello World\n') # 输入body&#125;).listen(8124); # 监听8124端口 #https 服务器 123456789var options = &#123; key: fs.readFileSync('./ssl/default.key'), #私钥 cert: fs.readFileSync('./ssl/default.cer') #公钥&#125;var server = https.createServer(options, function (request, response) &#123; //...&#125;) #http 客户端 12345678910111213141516var options = &#123; hostname: 'www.example.com', port: 80, path: '/upload', method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125;, rejectUnauthorized: false #https禁用证书有效性检查，开发的时候调试用&#125;var request = http.request(options, function (response) &#123;&#125;)request.write('Hello World')request.end() #url操作 123456789 href---------------------------------------------------------------- host path --------------- ---------------------------http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash----- ---------- -------- ---- ------- ------------- -----protocol auth hostname port pathname search hash ------------- query 12345678910111213141516url.parse('http://user:pass@host.com:8080/p/a/t/h?query=string#hash')/* =&gt;&#123; protocol: 'http', auth: 'user:pass', host: 'host.com:8080', port: '8080', hostname: 'host.com', hash: '#hash', search: '?query=string', query: 'query=string', pathname: '/p/a/t/h', path: '/p/a/t/h?query=string', href: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'&#125; #参考资料 七天学会NodeJS]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python3 代码块整理]]></title>
      <url>%2F2017%2F04%2F16%2FPython3-%E4%BB%A3%E7%A0%81%E5%9D%97%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[#接收命令行传参 12345678import sys#&gt;python3 test.py p1 p2print('py: %s | param1: %s | param2: %s' % (sys.argv[0],sys.argv[1],sys.argv[2])#&gt;py: test.py | param1: p1 | param2: p2 #异步编程 12345678910111213from threading import Threaddef thread_func1(count): count++ print("thread_func1: %d" % count)def thread_func2(count): count++ print('thread_func2: %d' % count)# 开启线程Thread(targe = thread_func1, args = (1,)).start()Thread(targe = thread_func2, args = (2,)).start() #网络请求 #Socket 12345678910111213import socket# 初始化套接字pSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 与服务器建立连接pSocket.connect((HOST,PORT))# 编码统一utf-8pMessage = pInput.encode('utf-8')# 给服务器发送消息pSocket.send(pMessage)# 接收从服务器传来的消息pRev = pSocket.recv(1024).decode('utf-8') #POST请求 12345678910111213import urllib.reques# 格式化请求参数data = urllib.parse.urlencode('param1': param) # utf-8编码data = data.encode('utf-8')# 初始化请求req = urllib.request.Request(url)# 发起请求获得responseresp = urllib.request.urlopen(req,data)# 对返回值进行'utf-8'解码resp_decoded = resp.read().decode('utf-8') #资源下载 123# 从url下载资源保存到pathurllib.request.urlretrieve(url,save_path) #文件目录 #目录处理 1234567891011121314import os# 判断path是否存在os.path.exist(path)# 是否是目录os.path.isdir(path)# 创建目录os.mkdir(path)# 重命名os.rename(old,new) #输入输出流 12345678910# 写入文件file = open(path,'w')file.write(data)file.close()# 读取文件file = open(path,'r')data = file.read()file.close() #文本处理 #json 1234567import json# 解析JSONdata = json.loads(json_data);# 编译成JSONjson_data = json.dumps(data) #编码解码 1234# utf-8编码data_encoded = data.encode('utf-8')# utf-8解码data_decoded = data.decode('utf-8') #字符串处理 1234567891011121314151617181920212223import re# 查找查找text.startswith('start')text.endswith('end')text.find('no')# 正则查找matchs = re.match(r'\d+/\d+/\d+',text)allmatchs = re.findall(r'\d+/\d+/\d+',text)# re可以先编译反复使用datapat = re.compile(r'\d+/\d+/\d+')maths = datapat.match(text)# 字符串替换# 找到字符串中和old匹配的字符串替换成newreplaced = str.replace(old,new)# 正则替换# 找到'.jpg'替换成'.jpg.cce'replaced = re.sub('.jpg','.jpg.cce',input_str) #字符串格式化 12345int_val = 1str_val = 'string'print('int_val: %d | str_val: %s' % (int_val,str_val)) #&gt; int_val: 1 | str_val: string #图片处理 123456789101112131415from PIL import Image# 打开图片big_image = Image.open(png_filename)box=(0, 0, 100, 100)# 复制图片左上角100,100的区域rect_on_big = big_image.crop(box)# 生成新图片size = [100,100]result_image = Image.new('RGBA', size, (0,0,0,0))# 拷贝的图片粘到新图片result_paste(rect_on_bg , box)# 保存图片result_image.save(outfile)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue-Weex开发环境搭建]]></title>
      <url>%2F2017%2F04%2F13%2FVue-Weex%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[Demo源码 #Weex开发 #工作原理 这里盗张Weex官方文档的图 由原理图，我们分三块来学习Weex 如何把Vue打包成JSBundle Android平台如何用JSBundle IOS平台如何使用JSBundle #如何把Vue打包成JSBundle #安装toolkit 12npm install -g weex-toolkit #新建项目 1$ weex init weex-demo #运行项目 12345cd weex-demonpm run devnpm run serve 在http://localhost:8080/index.html查看 注意：当前版本需要对weex.html做如下修改才能正常运行，要不会找不到index.js 1234&lt;!-- 官方的 --&gt;&lt;!-- &lt;script src="./node_modules/weex-vue-render/index.js"&gt;&lt;/script&gt; --&gt;&lt;!-- 修改后的 --&gt;&lt;script src="./node_modules/weex-vue-render/dist/index.js"&gt;&lt;/script&gt; #打包**.vue**文件 12weex compile src/foo.vue dist 运行完就会在dist文件夹下找到编译完的foo.js，这个就是打包好的JSBundle #Android平台如何用JSBundle 参考Android平台如何用JSBundle #参考 搭建Weex开发环境 使用 weex-toolkit]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Weex-Android开发]]></title>
      <url>%2F2017%2F04%2F13%2FWeex-Android%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[工程源码 WeexSDK最新版本jcenter #准备 AndroidStudio JDK version&gt;=1.7 Android SDK version 23 Android SDK build tools version 23.0.1 Android Support Repository &gt;= 17 #脚手架搭建 #创建新项目 使用AndroidStudio按习惯创建项目 #gradle配置 1234567891011121314151617181920212223242526272829303132apply plugin: 'com.android.application'android &#123; ...... /** * 必须加，否则64位手机无法加载so文件 */ ndk &#123; abiFilters "x86" abiFilters "armeabi" &#125; &#125; ......&#125;dependencies &#123; ...... compile 'com.android.support:appcompat-v7:24.2.1' compile 'com.android.support:recyclerview-v7:24.1.1' compile 'com.android.support:support-v4:24.1.1' compile 'com.android.support:appcompat-v7:24.1.1' //https://bintray.com/alibabaweex/maven/weex_sdk/view可以查看最新版本，尽量用最新的,0.9.5以下无法加载vue，血的教训 compile 'com.taobao.android:weex_sdk:0.11.0' compile 'com.alibaba:fastjson:1.1.56.android'//json解析 compile 'com.github.bumptech.glide:glide:3.7.0'//图片加载插件 ....&#125; #代码实现 实现图片下载接口，初始化时设置。 12345678910111213141516171819202122232425package weexdemo.loostudy.cn.weex_android_demo;import android.widget.ImageView;import com.bumptech.glide.Glide;import com.taobao.weex.adapter.IWXImgLoaderAdapter;import com.taobao.weex.common.WXImageStrategy;import com.taobao.weex.dom.WXImageQuality;/** * Created by bill on 2017/4/13. */public class ImageAdapter implements IWXImgLoaderAdapter &#123; @Override public void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; //实现自己的图片的下载，否则图片无法下载 //图片加载用glide实现 https://github.com/bumptech/glide Glide.with(view.getContext()) .load(url) .into(view); &#125;&#125; 初始化 1234567891011121314151617181920212223242526package weexdemo.loostudy.cn.weex_android_demo;import android.app.Application;import com.taobao.weex.InitConfig;import com.taobao.weex.WXSDKEngine;/** * Created by bill on 2017/4/13. *//** * 注意要在Manifest中设置android:name=".WXApplication" * 要实现ImageAdapter 否则图片不能下载 * gradle 中一定要添加一些依赖，否则初始化会失败。 */public class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); InitConfig config = new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build(); WXSDKEngine.initialize(this,config); &#125;&#125; 渲染 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package weexdemo.loostudy.cn.weex_android_demo;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import com.taobao.weex.IWXRenderListener;import com.taobao.weex.WXSDKInstance;import com.taobao.weex.common.WXRenderStrategy;import com.taobao.weex.utils.WXFileUtils;public class IndexActivity extends AppCompatActivity implements IWXRenderListener&#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_index); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * pageName 可以替换成自定义的字符串，针对埋点有效。 * template 是.we transform 后的 js文件。 * option 可以为空，或者通过option传入 js需要的参数。例如bundle js的地址等。 * jsonInitData 可以为空。 * flag:渲染策略。WXRenderStrategy.APPEND_ASYNC:异步策略先返回外层View，其他View渲染完成后调用onRenderSuccess。WXRenderStrategy.APPEND_ONCE 所有控件渲染完后后一次性返回。 */// mWXSDKInstance.render("localPage", WXFileUtils.loadAsset("foo.js", this), null, null, WXRenderStrategy.APPEND_ASYNC); mWXSDKInstance.renderByUrl("urlPage", "http://www.happygod.cn/foo.js", null, null, WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!= null) &#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!= null) &#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null) &#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!= null) &#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; Manifest添加网络权限 1&lt;uses-permission android:name="android.permission.INTERNET"&gt;&lt;/uses-permission&gt; #添加本地资源 在app/src/main目录下创建assets文件夹，里面放入打包好的foo.js #搭建完成 到此开发脚手架已经搭建完成！连接手机就可以运行调试，在Weex开发页面，打包完在渲染Activity里加渲染就可以看到效果。 #参考 WEEX SDK集成到工程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue-hackernews-2.0学习笔记]]></title>
      <url>%2F2017%2F04%2F12%2FVue-hackernews-2-0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[#目录结构 1234567891011121314151617181920212223242526272829303132333435.├── build| ├── setup-dev-server.js| ├── vue-loader.config.js| ├── webpack.base.config.js| ├── webpack.client.config.js| └── webpack.server.config.js├── src| ├── components| | ├── Comment.vue| | ├── item.vue| | ├── itemList.vue| | └── Spinner.vue| ├── filters| | └── index.js| ├── router| | └── index.js| ├── store| | ├── api.js| | ├── create-api-client.js| | ├── create-api-server.js| | └── index.js| ├── views| | ├── CreateListView.js| | ├── ItemView.vue| | └── UserView.vue| ├── app.js| ├── App.vue| ├── entry-client.js| ├── entry-server.js| └── index.template.html├── manifest.json├── package.json├── server.js└── yarn.lock #yarn文件 由于yarn的CLI生成 #架构预览 #package.json[1] 每个nodejs项目根目录，一般有一个package.json文件，定义这个项目所需要的各种模块，以及项目的配置信息。npm install命令根据这个配置文件，自动下载所需要的模块，也就是配置项目所需要的运行和开发环境。 #参数含义 12345678910111213141516171819202122232425&#123; "name": "vue-hackernews-2.0",//项目名字 "description": "A Vue.js project",//描述 "author": "Evan You &lt;yyx990803@gmail.com&gt;",//作者 "private": true, "scripts": &#123;//命令缩写 比如 npm run dev = node server ...... &#125;, "engines": &#123;//项目所需要的nodejs版本 "node": "&gt;=7.0", "npm": "&gt;=4.0" &#125;, //dependencies字段指定了项目运行所依赖的模块，devDependencies指定项目开发所需要的模块。 //指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。 //波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。 //插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。 //latest：安装最新版本。 "dependencies": &#123; ...... &#125;, "devDependencies": &#123; ...... &#125;&#125; #生成配置文件 1$ npm init 这个命令采用互动方式，要求用户回答一些问题，然后在当前目录生成一个基本的package.json文件。所有问题之中，只有项目名称（name）和项目版本（version）是必填的，其他都是选填的。 #添加依赖 12$ npm install express --save$ npm install express --save-dev 上面代码表示单独安装express模块，--save参数表示将该模块写入dependencies属性，--save-dev表示将该模块写入devDependencies属性。 #Dependencies傻傻分不清 参考[2]: dependencies是运行项目必须安装的依赖。 devDependencies是参与再开发需要安装的依赖，相当于开发工具。 peerDependencies是为插件准备的。比如grunt的插件，里面没有equire(&quot;grunt&quot;)，所以用dependencies会有问题。所以需要单独列出。 #参考资料 package.json文件 ↩ nodejs 依赖关系定义 ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017主攻技术选型]]></title>
      <url>%2F2017%2F04%2F10%2F2017%E4%B8%BB%E6%94%BB%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[#技术选型 服务端：通过DingoApi插件把Laravel作为Restful API框架使用 前端：VueJs通过官方推荐的axios插件调用服务端API 平台： 原生：使用阿里维护并且刚刚和VueJs作者深度合作的Weex框架导出原生应用 浏览器：通过TalkingData维护的IView UI组件渲染网页，通过Webpack打包发布浏览器版本 #自问自答 #为什么选VueJs前端MVVM框架 因为它支持原生平台，因为它比ReactJs轻，因为它的学习曲线没ReactJs陡峭，因为入门半个月了，前面的是瞎扯，因为它ICON的主页都是绿色的！就是那么任性 #为什么选Laravel做后端 因为对PHP相对比较熟悉，Laravel框架也使用过，同时找到一款可以把Laravel转化为Restful API的插件Dingoapi, VueJs也有axios插件这段官方推荐的ajax插件，这样就降低了学习成本，能比较平滑的用到生产环境中，毕竟对服务器渲染还不是很习惯。等项目稳定了，会逐步把Laravel把生产环境中剥离替换成NodeJs的Express，能发挥出vue-server特色 #为什么选择Webpack打包Web端 因为Vue初始化的配置就是使用webpack的，对它支持的会比较好。不需要特别去折腾配置的事情 #Weex和HBuilder的选择 本来是没什么好犹豫的，VueJs作者已经和Weex深度合作了。但鉴于Weex的Demo UI丑到一定境界了，同时又看到了这篇文章[1]，还有这个案列[2]。我又开始纠结这个选型了。不过还是给Weex一个机会吧。如果Weex实在无法忍就选择mui这个备胎 #为什么使用IView作为Web UI框架 因为它由中国最大的大数据平台TalkingData维护的一个UI项目，我一直很喜欢TalkingData的简洁的方格，这个UI框架的存在也让我很庆幸选择了VueJs作为前端技术栈 #技术官网 Laravel Dingoapi axios VueJs IView Webpack Weex ECMAScript 6 入门 NodeJs 包教不包会 #参考资料 H5移动前端框架之Avalon+MUI教程：一、技术选型 ↩ vue-html5plus ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Protobuf安装与入门]]></title>
      <url>%2F2017%2F04%2F08%2FProtobuf%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[#MAC下安装 #安装必要工具(如果没安装) 12brew install autoconf automake libtool curl make g++ unzip #安装Protobuf 1234567891011121314git clone https://github.com/google/protobuf.git./autogen.sh./configuremakemake checkmake install#MAC下不需要调用#ldconfig Mac下不需要调用ldconfig[1] #HelloWorld C++ #编写协议 1234567891011#创建需要的目录mkdir testcd testmkdir protosmkdir cccd protos#编辑协议文件vim addressbook.proto#编译协议到../cc文件夹protoc --cpp_out=../cc addressbook.proto addressbook.proto 123456789101112syntax = "proto2"package tutorial;message Person &#123; required string name = 1; required int32 age = 2;&#125;message AddressBook &#123; repeated Person person = 1;&#125; #编写测试代码 123456789#编写测试代码cd ../ccvim write.cppvim read.cpp#编译测试代码g++ addressbook.pb.cc write.cpp -o write `pkg-config --cflags --libs protobuf`g++ addressbook.pb.cc read.cpp -o read `pkg-config --cflags --libs protobuf` write.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include "addressbook.pb.h"using namespace std;void PromptForAddress(tutorial::Person *person) &#123; cout &lt;&lt; "Enter person name:" &lt;&lt; endl; string name; cin &gt;&gt; name; person-&gt;set_name(name); int age; cin &gt;&gt; age; person-&gt;set_age(age);&#125;int main(int argc, char **argv) &#123; //GOOGLE_PROTOBUF_VERIFY_VERSION; if (argc != 2) &#123; cerr &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " ADDRESS_BOOL_FILE" &lt;&lt; endl; return -1; &#125; tutorial::AddressBook address_book; &#123; fstream input(argv[1], ios::in | ios::binary); if (!input) &#123; cout &lt;&lt; argv[1] &lt;&lt; ": File not found. Creating a new file." &lt;&lt; endl; &#125; else if (!address_book.ParseFromIstream(&amp;input)) &#123; cerr &lt;&lt; "Filed to parse address book." &lt;&lt; endl; return -1; &#125; &#125; // Add an address PromptForAddress(address_book.add_person()); &#123; fstream output(argv[1], ios::out | ios::trunc | ios::binary); if (!address_book.SerializeToOstream(&amp;output)) &#123; cerr &lt;&lt; "Failed to write address book." &lt;&lt; endl; return -1; &#125; &#125; // Optional: Delete all global objects allocated by libprotobuf. //google::protobuf::ShutdownProtobufLibrary(); return 0;&#125; read.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include "addressbook.pb.h"using namespace std;void ListPeople(const tutorial::AddressBook&amp; address_book) &#123; for (int i = 0; i &lt; address_book.person_size(); i++) &#123; const tutorial::Person&amp; person = address_book.person(i); cout &lt;&lt; person.name() &lt;&lt; " " &lt;&lt; person.age() &lt;&lt; endl; &#125;&#125;int main(int argc, char **argv) &#123; //GOOGLE_PROTOBUF_VERIFY_VERSION; if (argc != 2) &#123; cerr &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " ADDRESS_BOOL_FILE" &lt;&lt; endl; return -1; &#125; tutorial::AddressBook address_book; &#123; fstream input(argv[1], ios::in | ios::binary); if (!address_book.ParseFromIstream(&amp;input)) &#123; cerr &lt;&lt; "Filed to parse address book." &lt;&lt; endl; return -1; &#125; input.close(); &#125; ListPeople(address_book); // Optional: Delete all global objects allocated by libprotobuf. //google::protobuf::ShutdownProtobufLibrary(); return 0;&#125; #测试结果 123456./write file&gt;&gt;file: File not found. Creating a new file.&gt;&gt;Enter person name:&gt;&gt;loostudy 18./read file&gt;&gt;loostudy 18 #总结 陌生代码块 123456789101112131415161718cin &gt;&gt; name; //输入结果遇到 Enter、Space、Tab 被截断fstream input(argv[1], ios::in | ios::binary); //输入流fstream output(argv[1], ios::out | ios::trunc | ios::binary); //输出流tutorial::AddressBook address_book; //声明协议address_book.ParseFromIstream(&amp;input) //解析协议address_book.SerializeToOstream(&amp;output) //序列化洗衣address_book.add_person() //添加repeated元素，返回Person指针，可对Person做修改person-&gt;set_name(name); //设置变量person.name(); //获取变量 到此入门安装测试已完成，目前对Protobuf的理解就是，通过一个.proto文件定义，协议格式，这份协议可以通过命令行protoc编译成不同语言对象格式。可以跨语言调用。 关于Protobuf的语法，和类库的引入(测试代码中是通过pkg-config --cflags --libs protobuf引入的，目前不太理解原理)以及protobuf2和protobuf3的区别做进一步研究整理。 #参考资料 google protobuf安装与使用 sudo: ldconfig: command not found for C++ installation on Mac OS X, Sierra ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Next主题净化主页]]></title>
      <url>%2F2017%2F04%2F07%2FNext%E4%B8%BB%E9%A2%98%E5%87%80%E5%8C%96%E4%B8%BB%E9%A1%B5%2F</url>
      <content type="text"><![CDATA[#前言 Next默认主题主页导航内容有些啰嗦，而且时常会因为&lt;!-- more --&gt;出BUG导致排版很难看。所以决定把主页净化一下。 主页的作用很简单，就是只要显示标题，时间，类型就可以了。来看看净化前的效果 #优化 打开themes/next/layout/_macro/post.swig 注释掉选中内容 123456&#123;% if is_index %&#125; &#123;# ReadMore 内容显示 &#123;% if post.description and theme.excerpt_description %&#125; &#123;% endif %&#125; #&#125;&#123;% else %&#125; 打开themes/next/source/css/_schemes/Mist/_posts-expanded.styl，修改样式 12//.post &#123; margin-top: 120px; &#125;.post &#123; margin-top: 0px; font-family: Chunkfive; src: url('Chunkfive.otf');&#125; 我用的是Mist样式。其他样式可以找对应样式目录 #优化后 明显导航干净很多，突出重点！ 注： 有其他需要修改的内容，可以在post.swig内搜索is_index参数，这个参数表示是导航页]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cocos2dx网络编程Socket]]></title>
      <url>%2F2017%2F04%2F06%2FCocos2dx%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BSocket%2F</url>
      <content type="text"><![CDATA[#[ProtoBuf][1] 待整理 #参考资料 cocos2dx_socket_example 1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cocos2dx预编译与模板]]></title>
      <url>%2F2017%2F04%2F06%2FCocos2dx%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[一条命令创建预编译洁净Cocos2dx工程 #前言 新建的Cocos2dx工程第一次编译至少十分钟，打包Android工程又需要再花十分钟左右再编译一次。每次新建项目都要再次把这些时间浪费在编译上。 当你想发布版本到Appstore,你需要Archive。有无限提交失败经验的人应该知道那是有多崩溃。 想要给游戏添加网上开源的模块，但又不确定可行性。最理想的方式就是应该建一个新项目，克隆代码，测试功能，然后再用到生产环境中。但新项目的编译阴影要么让我放弃了好模块的引入，要么就是直接引入造成一系列BUG！ 受到这个帖子[1]的启发 我决定拔掉这根刺了！ 找了些资料自己做了下尝试，准备从模板，预编译，相关配置，解决这些烦恼。 想要达到的效果是cocos new project_name -p package -l cpp -t template这一条命令就完成所有需要的配置，之后的开发只需要关心业务需求。不需要额外配置，无论ios还是android都是可以10秒内完成编译 #预编译类库 修改Android以下项目配置文件，修改目标安卓版本到你已安装的版本[2] 预编译目标项目： cocos2d-x-3.13.1\tools\simulator\frameworks\runtime-src\proj.android\project.properties cocos2d-x-3.13.1\cocos\platform\android\java\project.properties 1target=android-19 注意！ ANDROID_SDK_ROOT环境变量cocos2dx只认bash的，也就是无论你使用哪个shell,都必须保证~/.bash_profile文件内配置的环境变量正确，否则会找不到SDK 如果以前预编译过，请删除cocos2d-x-3.13.1\tools\simulator\frameworks\runtime-src\proj.android\obj目录再重新编译 使用gen-libs命令预编译类库[3],编译完的类库在$(COCOS2DX_ROOT)/prebuilt,这里不能用-m debug，原因见[4] 1cocos gen-libs -p ios -p android 使用lipo命令查看静态链接库a支持的构架 12345lipo -info /Usashers/bill/sdks/Cocos2d-x/cocos2d-x-3.13.1/prebuilt/ios/libcocos2d\ iOS.a#-m debug不支持x86_64 arm64 无法跑模拟器和真机Architectures in the fat file: /Users/bill/sdks/Cocos2d-x/cocos2d-x-3.13.1/prebuilt/ios/libcocos2d iOS.a are: i386 armv7#不添加-m debugArchitectures in the fat file: /Users/bill/sdks/Cocos2d-x/cocos2d-x-3.13.1/prebuilt/ios/libcocos2d iOS.a are: i386 armv7 x86_64 arm64 #自定义模板 #删除不需要的目录 在$(COCOS2DX_ROOT)/template复制份cpp-template-default模板，改名为cpp-template-prebuilt 由于我只需要ios和android,所以我可以删除其他目录，然后修改模板配置cocos-project-template.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; "do_default":&#123; "project_rename":&#123; "src_project_name":"HelloCpp", "files":[ "proj.ios_mac/PROJECT_NAME.xcodeproj" ] &#125;, "project_replace_project_name":&#123; "src_project_name":"HelloCpp", "files":[ "Classes/AppDelegate.cpp", "proj.android-studio/settings.gradle", "proj.android-studio/app/res/values/strings.xml", "proj.ios_mac/ios/main.m", "proj.ios_mac/ios/Prefix.pch", "proj.ios_mac/PROJECT_NAME.xcodeproj/project.pbxproj" ] &#125;, "project_replace_package_name":&#123; "src_package_name":"org.cocos2dx.hellocpp", "files":[ "proj.android-studio/app/build.gradle", "proj.android-studio/app/AndroidManifest.xml" ] &#125;, "project_replace_ios_bundleid": &#123; "src_bundle_id": "org.cocos2dx.hellocpp", "files": [ "proj.ios_mac/ios/Info.plist" ] &#125; &#125;, "change_orientation": &#123; "modify_files": [ &#123; "file_path": "Classes/AppDelegate.cpp", "pattern": "static\\s+cocos2d\\:\\:Size\\s+([a-zA-Z_\\d]+)\\s*=\\s*cocos2d\\:\\:Size\\(\\s*(\\d+),\\s*(\\d+)\\)", "replace_string": "static cocos2d::Size \\1 = cocos2d::Size(\\3, \\2)" &#125;, &#123; "file_path": "proj.ios_mac/ios/Info.plist", "pattern": "UIInterfaceOrientationLandscapeRight", "replace_string": "UIInterfaceOrientationPortrait" &#125;, &#123; "file_path": "proj.ios_mac/ios/Info.plist", "pattern": "UIInterfaceOrientationLandscapeLeft", "replace_string": "UIInterfaceOrientationPortraitUpsideDown" &#125;, &#123; "file_path": "proj.android-studio/app/AndroidManifest.xml", "pattern": "android:screenOrientation=\\\".*\\\"", "replace_string": "android:screenOrientation=\"portrait\"" &#125; ] &#125;&#125; #添加.gitignore 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# Created by .ignore support plugin (hsz.mobi)### cocos2dx template### C++ template# Prerequisites*.d# Compiled Object files*.slo*.lo*.o*.obj# Precompiled Headers*.gch*.pch# Compiled Dynamic libraries*.so*.dylib*.dll# Fortran module files*.mod*.smod# Compiled Static libraries*.lai*.la*.a*.lib# Executables*.exe*.out*.app### Xcode template# Xcode## gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore## Build generatedbuild/DerivedData/## Various settings*.pbxuser!default.pbxuser*.mode1v3!default.mode1v3*.mode2v3!default.mode2v3*.perspectivev3!default.perspectivev3xcuserdata/## Other*.moved-aside*.xccheckout*.xcscmblueprint #模板项目配置 #Xcode 导入libcocos2d IOS.a静态链接库 参考[5]添加Xcode自定义COCOS2DX_ROOT变量 参考[6]配置Header Search Paths 配置Library Search Paths #Android Studio #Gradle配置 编辑gradle/wrapper/gradle-wrapper.properties,修改下面行 1https\://services.gradle.org/distributions/gradle-2.14.1-all.zip 编辑build.gradle 1234567buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; // classpath 'com.android.tools.build:gradle:1.3.0' classpath 'com.android.tools.build:gradle:2.2.3' #编辑Android.mk[7] 1234567#$(call import-add-path,$(LOCAL_PATH)/../../../cocos2d)#$(call import-add-path,$(LOCAL_PATH)/../../../cocos2d/external)#$(call import-add-path,$(LOCAL_PATH)/../../../cocos2d/cocos)#$(call import-add-path,$(LOCAL_PATH)/../../../cocos2d/cocos/audio/include)#$(call import-module,.)$(call import-module,./prebuilt-mk) #编辑build-cfg.json[7] 1234567891011121314&#123; "ndk_module_path" :[ "/Users/bill/sdks/Cocos2d-x/cocos2d-x-3.13.1", "/Users/bill/sdks/Cocos2d-x/cocos2d-x-3.13.1/cocos/prebuilt-mk", "/Users/bill/sdks/Cocos2d-x/cocos2d-x-3.13.1/cocos", "/Users/bill/sdks/Cocos2d-x/cocos2d-x-3.13.1/external" ], "copy_resources": [ &#123; "from": "../Resources", "to": "" &#125; ]&#125; #编辑prebuilt-mk 编辑$(COCOS2DX_ROOT)/cocos/prebuilt-mk/Android.mk,参考[8] 1# $(call import-module, android/cpufeatures/prebuilt-mk) #添加cocos2dx类库 把$(COCOS2DX_ROOT)/cocos/platform/android/下对应文件拷贝到模板对应目录 #新建模板项目 1cocos new SocketDemo -p my.first.prebuilt -l cpp -t prebuilt 生成包体大小5.4M，开箱即用，编译IOS版 6秒。安卓版慢一点，要1分钟左右。我看LOG是还在编译一些类库。不过这已经是质的飞跃了！ 以后找网上的好代码，直接建个新工程测试就可以了！ #遗留问题 用我的模板生成的工程Schemes名字没有替换成我工程的名字（默认模板是可以的），无法直接运行，需要进Edit Scheme，选择Executable。然后就可以运行 解决办法 找到$(COCOS2DX_ROOT)/templates/cpp-template-prebuilt/HelloCpp.xcodeproj，右键显示包内容，删除xcuserdata文件夹，一切OK! #参考资料 cocos2d-x-3.13.1版本预编译库的使用 ↩ –ap in cocos gen-libs didn’t work. ↩ cocos gen-libs文档 ↩ cocos gen-libs -m debug 只支持i386 armv7 ↩ Xcode设置自定义Build Setting ↩ xcode路径配置 ↩ How to speed up cocos2d-x build with prebuilt lib ↩ ↩ Cannot find module with tag ‘android/cpufeatures/prebuilt-mk’ ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo版本维护]]></title>
      <url>%2F2017%2F04%2F05%2FHexo%E7%89%88%E6%9C%AC%E7%BB%B4%E6%8A%A4%2F</url>
      <content type="text"><![CDATA[维护Hexo项目的版本以及如何在新环境继续复刻版本 #前言 hexo部署只是把public内生成的静态文件提交到page仓库，但md文件、配置文件、主题文件并没有维护版本。 为了应对意外情况以及在新环境下依旧可以更新博客，需要把这些内容的版本维护起来 #版本维护[1] 用Coding仓库的分支hexo来维护版本,这样不会污染作为page展示的master分支内容 1234567cd 项目根目录git initgit remote coding 你的仓库地址.gitgit add .git common -m '提交描述'git branch hexo #创建分支git push coding hexo #提交到分支 #新机器获取版本 123git clone 你的仓库地址.gitgit checkout hexonpm install 然后就可以开始写作和部署了 注意：在新机器上需要自己先部署好nodejs,npm,hexo环境！ #参考资料 在不同的电脑维护Hexo和写作 ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo图床]]></title>
      <url>%2F2017%2F04%2F05%2FHexo%E5%9B%BE%E5%BA%8A%2F</url>
      <content type="text"><![CDATA[七牛静态资源同步插件hexo-qiniu-sync安装配置 #安装插件[1] 1npm install hexo-qiniu-sync --save #获取七牛的AK和SK 参考网页[2]，如到七牛后台的如下入口获取密钥 #配置插件 参考网页[3]配置根目录_config.yml 12345678910111213141516171819202122232425# 七牛同步qiniu: offline: false sync: true bucket: bucket name #secret_file: sec/qn.json or C: access_key: your ak secret_key: your sk #bucket静态资源存放目录 dirPrefix: static #给url添加的前缀，格式 七牛分配的域名+dirPrefix urlPrefix: your-url/static #图片上传url，默认即可 up_host: http://upload.qiniu.com #本地静态资源存放目录 local_dir: static update_exist: true #资源目录配置 image: folder: images extend: js: folder: js css: folder: css #初始化静态资源路径 运行hexo g命令可以根据配置初始化必要的存放资源路径，只要把需要同步的图片资源放到static/images里就可以了 #使用七牛图片 在文章中需要用到图片的位置插入 1&#123;% qnimg qiniu-logo.png title:七牛云 logo alt:七牛云 'class:' extend:?imageView2/2/w/550 %&#125; #同步图片到七牛 hexo s和hexo qiniu sync|sync2都可以同步图片 #CDN资源缓存问题解决 #添加? v= 用户在开发中，需要更新图片， css，html 等静态资源。而且在七牛是同名资源覆盖，这就导致文件在七牛源站更新后，却取的是 cdn 的旧缓存。所以用户可以每次更新文件的时候，在自己网站发布时候，对资源做? v=… 的版本替换。这样就可以保证更新后访问的是新的了。 #云储存上刷新 #参考资料 hexo-qiniu-sync官网 ↩ 如何获取七牛云存储的AccessKey和SecretKey ↩ 七牛同步插件使用 ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo写作必备]]></title>
      <url>%2F2017%2F04%2F05%2FHexo%E5%86%99%E4%BD%9C%E5%BF%85%E5%A4%87%2F</url>
      <content type="text"><![CDATA[HexoAdmin安装部署，和Hexo内置标签整理 #HexoAdmin[1] HexoAdmin是一个可视化编辑，管理和部署Hexo博客的后台插件。 #安装 在hexo项目根目录安装 1➜ hexo-site npm install --save hexo-admin #运行 1➜ hexo-site hexo s 在浏览器打开 http://localhost:4000/admin/ 主界面 账户密码设置界面 #写作 这里没什么可说的，点击New Post之后就可以可视化编辑了。 值得一提的是，添加图片的时候不是拖拽，是复制粘贴 复制粘贴 复制粘贴！！！ #部署 1touch hexo-deploy.sh; chmod a+x hexo-deploy.sh 在hexo-deploy.sh内添加两行，参考https://github.com/vladpurga/hexo-admin-deploy-command 12#!/usr/bin/env shhexo deploy 编辑_config.yml 12admin: deployCommand: './hexo-deploy.sh' 按说明操作部署就OK了！ 在部署过程中遇到一个很诡异的问题： 指定hexo d命令报错： fatal: unable to access 'https://git.coding.net/loostudy/loostudy.coding.me.git/': The requested URL returned error: 500 但是仓库的确是存在可用的，找了半天原因，最后我把在根目录的.git文件夹删掉就一切正常了！之后git init重新初始化版本维护依旧正常，不知道什么原因。 #Next内置标签[2] #文本居中引用 12345&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;居中引用&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; 居中引用 &#123;% endcq %&#125; 效果 居中引用 #笔记框note 12#可选class name &gt; default primary success info warning danger&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 效果 default primary success warning info danger #Hexo内置标签[3] #插入图片 Markdown格式插入图片无法修改大小，而且Hexo不支持Markdown的title，需要修改带下和增加title需要使用内放标签 1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; #引用自己的文章 123&#123;% post_link post文件名 别名 %&#125;比如&#123;% post_link Hexo建站宝典 宝典！%&#125; 宝典！ #hexo-renderer-markdown-it插件[4] #安装插件 12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save #配置_config.yml 123456789101112131415161718192021222324# Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki/markdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: '“”‘’' plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup #自动生成永久链接标记，鼠标点击标题后面的permalinkSymbol符号，会调转到新的固定链接。 #使用这个链接可以直接跳转到这个标题位置 anchors: level: 2 collisionSuffix: 'v' permalink: true permalinkClass: header-anchor permalinkSymbol: '#' #默认标示太难看，改成#号 #永久链接 配置anchors属性可以给每个标题添加永久链接 点击这个标记会生成形如这样的链接 http://localhost:4000/2017/04/05/Hexo%E5%BB%BA%E7%AB%99%E5%AE%9D%E5%85%B8/#进阶 使用这个链接可以直接跳转到这个标题 #添加注脚 12内容[^1][^1]: 这里是注脚 #[BUG]内置more标签失效 参照网页[5]解决插件本身造成的BUG。如果已经无效的话，请确认&lt;!-- more --&gt;上下行时候有空格，一定要空格隔开，要不也会失效 1234缩略描述 //缩略描述也是必须的//空格是必须的&lt;!-- more --&gt;//空格是必须的 #参考资料 Hexo-Admin主页 ↩ Next内置标签 ↩ Hexo内置标签 ↩ use-hexo-renderer-markdown-it ↩ Hexo + Markdown issues ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo建站宝典]]></title>
      <url>%2F2017%2F04%2F05%2FHexo%E5%BB%BA%E7%AB%99%E5%AE%9D%E5%85%B8%2F</url>
      <content type="text"><![CDATA[Hexo从零开始到Coding部署个人博客 #Hexo安装配置 #安装Hexo 1$ npm install -g hexo-cli #新建站点文件 1$ hexo init &lt;foldname&gt; #创建新post 1$ hexo n 'name' #更新 1$ hexo g #清理 1$ hexo clean #每次发布前建议清理下，尤其是在更改样式和脚本的时候，会有缓存 #本地服务器 1$ hexo s #Next主题安装配置 #下载 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next #站点配置 站点目录下的_config.yml文件 123456789101112131415#站点标题title: LOOSTUDY#站点小标题subtitle: 绽放时厚积薄发 等待时心如止水#站点描述description: 绽放时厚积薄发 等待时心如止水#作者名author: loostudy#选择语言简体中文language: zh-Hans...#选择主题nexttheme: next #主题配置 站点目录下的\themes\next\_config.yml文件 1234567#修改scheme#scheme: Musescheme: Mist#scheme: Pisces#修改代码高亮主题 可选值 normal，night， night blue， night bright， night eightieshighlight_theme: night bright #进阶 #修改post模板 打开scaffolds\post.md 1234567---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;#添加分类categories:tags:--- #标签和分类[1] #修改文章md内的分类 1categories: 编程 #映射文件夹，修改站点目录下的_config.yml文件 123456default_category: uncategorizedcategory_map: 编程: programming 生活: life 其他: othertag_map: #文章多标签使用 1tages: [标签1,标签2,...标签n] #Next标签[2]分类[3]页面 #新建 1234#新建标签页$ hexo new page tags#新建分类页$ hexo new page categories #修改标签分类页面内容 12345title: 标签date: 2014-12-22 12:39:04type: "tags"comments: false--- 12345title: 分类date: 2014-12-22 12:39:04type: "categories"comments: false--- #Next主页导航优化[4] #more标签 在文章title后面添加&lt;!-- more --&gt;标签 12345678---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:---简单说明&lt;!-- more --&gt; #部署到Codiing #安装hexo-deployer-git 1$ npm install hexo-deployer-git --save #修改配置 这里一定要用master分支，coding-pages分支测试无效 1234deploy: type: git repo: coding: https://git.coding.net/loostudy/loostudy.coding.me.git,master #绑定证书 生成证书 1ssh-keygen -t rsa -C "邮箱" 把证书的公钥(~/.ssh/id_rsa.pub)的内容拷贝到coding个人账户下的SSH公钥里面 #部署 由于coding的Pages服务是默认执行jekyll项目, 静态项目需要一个.nojekyll文件标识. 所以第一次执行, 需要在生成的public文件夹中加入一个 .nojekyll 空白文件 1hexo d #Hexo修改文件夹大小写问题 当你想把catagory或者tag修改大小写的时候，你重新部署会发现，上传到服务器的文件夹大小写没变，导致请求改tag和catagory URL的时候显示404。要解决这个问题要做一下两步：[5] 删除.deploy_git目录 再次运行hexo d提交，hexo会重置git仓库，并重新生成所有文件! 可以使用下面语句设置git大小写敏感，防止下次出现这样的问题： 12git config core.ignorecase false #参考资料 Hexo使用攻略：（四）Hexo的分类和标签设置 ↩ Next添加标签页面 ↩ Next添加分类页面 ↩ 如何实现首页文章,只显示标题而不是全文 ↩ Hexo部署到Github上文件夹的大小写问题 ↩]]></content>
    </entry>

    
  
  
</search>
