<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[NodeJs学习笔记]]></title>
      <url>%2F2017%2F04%2F16%2FNodeJs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[#入口模块 package.json 1234&#123; "main": "xxx.js" //定义入口模块&#125; #通常项目包含 123456789- project + bin # 命令行相关代码 + doc # 文档 + lib # api相关代码 + node_modules # 存放三方包 + tests # 测试用例 package.json # 元数据文件 README.md # 说明文件 #NPM发布代码 1234npm adduser #注册账号npm publish #发布代码 #BOM移除 12345678910function readText(pathname) &#123; var bin = fs.readFileSync(pathname) if (bin[0] === 0xEF &amp;&amp; bin[1] === 0xBB &amp;&amp; bin[2] === 0xBF) &#123; bin = bin.slice(3) &#125; return bin.toString('utf-8');&#125; #http请求 #http 服务器 1234567var http = require('http') # 引用http模块http.createServer(function (request, response) &#123; response.writeHead(200, &#123; 'Content-Type': 'text-plain'&#125;) # 写入http头 response.end('Hello World\n') # 输入body&#125;).listen(8124); # 监听8124端口 #https 服务器 123456789var options = &#123; key: fs.readFileSync('./ssl/default.key'), #私钥 cert: fs.readFileSync('./ssl/default.cer') #公钥&#125;var server = https.createServer(options, function (request, response) &#123; //...&#125;) #http 客户端 12345678910111213141516var options = &#123; hostname: 'www.example.com', port: 80, path: '/upload', method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125;, rejectUnauthorized: false #https禁用证书有效性检查，开发的时候调试用&#125;var request = http.request(options, function (response) &#123;&#125;)request.write('Hello World')request.end() #url操作 123456789 href---------------------------------------------------------------- host path --------------- ---------------------------http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash----- ---------- -------- ---- ------- ------------- -----protocol auth hostname port pathname search hash ------------- query 12345678910111213141516url.parse('http://user:pass@host.com:8080/p/a/t/h?query=string#hash')/* =&gt;&#123; protocol: 'http', auth: 'user:pass', host: 'host.com:8080', port: '8080', hostname: 'host.com', hash: '#hash', search: '?query=string', query: 'query=string', pathname: '/p/a/t/h', path: '/p/a/t/h?query=string', href: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'&#125; #参考资料 七天学会NodeJS]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python3 代码块整理]]></title>
      <url>%2F2017%2F04%2F16%2FPython3-%E4%BB%A3%E7%A0%81%E5%9D%97%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[#接收命令行传参 12345678import sys#&gt;python3 test.py p1 p2print('py: %s | param1: %s | param2: %s' % (sys.argv[0],sys.argv[1],sys.argv[2])#&gt;py: test.py | param1: p1 | param2: p2 #异步编程 12345678910111213from threading import Threaddef thread_func1(count): count++ print("thread_func1: %d" % count)def thread_func2(count): count++ print('thread_func2: %d' % count)# 开启线程Thread(targe = thread_func1, args = (1,)).start()Thread(targe = thread_func2, args = (2,)).start() #网络请求 #Socket 12345678910111213import socket# 初始化套接字pSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 与服务器建立连接pSocket.connect((HOST,PORT))# 编码统一utf-8pMessage = pInput.encode('utf-8')# 给服务器发送消息pSocket.send(pMessage)# 接收从服务器传来的消息pRev = pSocket.recv(1024).decode('utf-8') #POST请求 12345678910111213import urllib.reques# 格式化请求参数data = urllib.parse.urlencode('param1': param) # utf-8编码data = data.encode('utf-8')# 初始化请求req = urllib.request.Request(url)# 发起请求获得responseresp = urllib.request.urlopen(req,data)# 对返回值进行'utf-8'解码resp_decoded = resp.read().decode('utf-8') #资源下载 123# 从url下载资源保存到pathurllib.request.urlretrieve(url,save_path) #文件目录 #目录处理 1234567891011121314import os# 判断path是否存在os.path.exist(path)# 是否是目录os.path.isdir(path)# 创建目录os.mkdir(path)# 重命名os.rename(old,new) #输入输出流 12345678910# 写入文件file = open(path,'w')file.write(data)file.close()# 读取文件file = open(path,'r')data = file.read()file.close() #文本处理 #json 1234567import json# 解析JSONdata = json.loads(json_data);# 编译成JSONjson_data = json.dumps(data) #编码解码 1234# utf-8编码data_encoded = data.encode('utf-8')# utf-8解码data_decoded = data.decode('utf-8') #字符串处理 1234567891011121314151617181920212223import re# 查找查找text.startswith('start')text.endswith('end')text.find('no')# 正则查找matchs = re.match(r'\d+/\d+/\d+',text)allmatchs = re.findall(r'\d+/\d+/\d+',text)# re可以先编译反复使用datapat = re.compile(r'\d+/\d+/\d+')maths = datapat.match(text)# 字符串替换# 找到字符串中和old匹配的字符串替换成newreplaced = str.replace(old,new)# 正则替换# 找到'.jpg'替换成'.jpg.cce'replaced = re.sub('.jpg','.jpg.cce',input_str) #字符串格式化 12345int_val = 1str_val = 'string'print('int_val: %d | str_val: %s' % (int_val,str_val)) #&gt; int_val: 1 | str_val: string #图片处理 123456789101112131415from PIL import Image# 打开图片big_image = Image.open(png_filename)box=(0, 0, 100, 100)# 复制图片左上角100,100的区域rect_on_big = big_image.crop(box)# 生成新图片size = [100,100]result_image = Image.new('RGBA', size, (0,0,0,0))# 拷贝的图片粘到新图片result_paste(rect_on_bg , box)# 保存图片result_image.save(outfile)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue-Weex开发环境搭建]]></title>
      <url>%2F2017%2F04%2F13%2FVue-Weex%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[Demo源码 #Weex开发 #工作原理 这里盗张Weex官方文档的图 由原理图，我们分三块来学习Weex 如何把Vue打包成JSBundle Android平台如何用JSBundle IOS平台如何使用JSBundle #如何把Vue打包成JSBundle #安装toolkit 12npm install -g weex-toolkit #新建项目 1$ weex init weex-demo #运行项目 12345cd weex-demonpm run devnpm run serve 在http://localhost:8080/index.html查看 注意：当前版本需要对weex.html做如下修改才能正常运行，要不会找不到index.js 1234&lt;!-- 官方的 --&gt;&lt;!-- &lt;script src="./node_modules/weex-vue-render/index.js"&gt;&lt;/script&gt; --&gt;&lt;!-- 修改后的 --&gt;&lt;script src="./node_modules/weex-vue-render/dist/index.js"&gt;&lt;/script&gt; #打包**.vue**文件 12weex compile src/foo.vue dist 运行完就会在dist文件夹下找到编译完的foo.js，这个就是打包好的JSBundle #Android平台如何用JSBundle 参考Android平台如何用JSBundle #参考 搭建Weex开发环境 使用 weex-toolkit]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Weex-Android开发]]></title>
      <url>%2F2017%2F04%2F13%2FWeex-Android%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[工程源码 WeexSDK最新版本jcenter #准备 AndroidStudio JDK version&gt;=1.7 Android SDK version 23 Android SDK build tools version 23.0.1 Android Support Repository &gt;= 17 #脚手架搭建 #创建新项目 使用AndroidStudio按习惯创建项目 #gradle配置 1234567891011121314151617181920212223242526272829303132apply plugin: 'com.android.application'android &#123; ...... /** * 必须加，否则64位手机无法加载so文件 */ ndk &#123; abiFilters "x86" abiFilters "armeabi" &#125; &#125; ......&#125;dependencies &#123; ...... compile 'com.android.support:appcompat-v7:24.2.1' compile 'com.android.support:recyclerview-v7:24.1.1' compile 'com.android.support:support-v4:24.1.1' compile 'com.android.support:appcompat-v7:24.1.1' //https://bintray.com/alibabaweex/maven/weex_sdk/view可以查看最新版本，尽量用最新的,0.9.5以下无法加载vue，血的教训 compile 'com.taobao.android:weex_sdk:0.11.0' compile 'com.alibaba:fastjson:1.1.56.android'//json解析 compile 'com.github.bumptech.glide:glide:3.7.0'//图片加载插件 ....&#125; #代码实现 实现图片下载接口，初始化时设置。 12345678910111213141516171819202122232425package weexdemo.loostudy.cn.weex_android_demo;import android.widget.ImageView;import com.bumptech.glide.Glide;import com.taobao.weex.adapter.IWXImgLoaderAdapter;import com.taobao.weex.common.WXImageStrategy;import com.taobao.weex.dom.WXImageQuality;/** * Created by bill on 2017/4/13. */public class ImageAdapter implements IWXImgLoaderAdapter &#123; @Override public void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; //实现自己的图片的下载，否则图片无法下载 //图片加载用glide实现 https://github.com/bumptech/glide Glide.with(view.getContext()) .load(url) .into(view); &#125;&#125; 初始化 1234567891011121314151617181920212223242526package weexdemo.loostudy.cn.weex_android_demo;import android.app.Application;import com.taobao.weex.InitConfig;import com.taobao.weex.WXSDKEngine;/** * Created by bill on 2017/4/13. *//** * 注意要在Manifest中设置android:name=".WXApplication" * 要实现ImageAdapter 否则图片不能下载 * gradle 中一定要添加一些依赖，否则初始化会失败。 */public class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); InitConfig config = new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build(); WXSDKEngine.initialize(this,config); &#125;&#125; 渲染 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package weexdemo.loostudy.cn.weex_android_demo;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import com.taobao.weex.IWXRenderListener;import com.taobao.weex.WXSDKInstance;import com.taobao.weex.common.WXRenderStrategy;import com.taobao.weex.utils.WXFileUtils;public class IndexActivity extends AppCompatActivity implements IWXRenderListener&#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_index); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * pageName 可以替换成自定义的字符串，针对埋点有效。 * template 是.we transform 后的 js文件。 * option 可以为空，或者通过option传入 js需要的参数。例如bundle js的地址等。 * jsonInitData 可以为空。 * flag:渲染策略。WXRenderStrategy.APPEND_ASYNC:异步策略先返回外层View，其他View渲染完成后调用onRenderSuccess。WXRenderStrategy.APPEND_ONCE 所有控件渲染完后后一次性返回。 */// mWXSDKInstance.render("localPage", WXFileUtils.loadAsset("foo.js", this), null, null, WXRenderStrategy.APPEND_ASYNC); mWXSDKInstance.renderByUrl("urlPage", "http://www.happygod.cn/foo.js", null, null, WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!= null) &#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!= null) &#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null) &#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!= null) &#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; Manifest添加网络权限 1&lt;uses-permission android:name="android.permission.INTERNET"&gt;&lt;/uses-permission&gt; #添加本地资源 在app/src/main目录下创建assets文件夹，里面放入打包好的foo.js #搭建完成 到此开发脚手架已经搭建完成！连接手机就可以运行调试，在Weex开发页面，打包完在渲染Activity里加渲染就可以看到效果。 #参考 WEEX SDK集成到工程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue-hackernews-2.0学习笔记]]></title>
      <url>%2F2017%2F04%2F12%2FVue-hackernews-2-0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[#目录结构 1234567891011121314151617181920212223242526272829303132333435.├── build| ├── setup-dev-server.js| ├── vue-loader.config.js| ├── webpack.base.config.js| ├── webpack.client.config.js| └── webpack.server.config.js├── src| ├── components| | ├── Comment.vue| | ├── item.vue| | ├── itemList.vue| | └── Spinner.vue| ├── filters| | └── index.js| ├── router| | └── index.js| ├── store| | ├── api.js| | ├── create-api-client.js| | ├── create-api-server.js| | └── index.js| ├── views| | ├── CreateListView.js| | ├── ItemView.vue| | └── UserView.vue| ├── app.js| ├── App.vue| ├── entry-client.js| ├── entry-server.js| └── index.template.html├── manifest.json├── package.json├── server.js└── yarn.lock #yarn文件 由于yarn的CLI生成 #架构预览 #package.json[1] 每个nodejs项目根目录，一般有一个package.json文件，定义这个项目所需要的各种模块，以及项目的配置信息。npm install命令根据这个配置文件，自动下载所需要的模块，也就是配置项目所需要的运行和开发环境。 #参数含义 12345678910111213141516171819202122232425&#123; "name": "vue-hackernews-2.0",//项目名字 "description": "A Vue.js project",//描述 "author": "Evan You &lt;yyx990803@gmail.com&gt;",//作者 "private": true, "scripts": &#123;//命令缩写 比如 npm run dev = node server ...... &#125;, "engines": &#123;//项目所需要的nodejs版本 "node": "&gt;=7.0", "npm": "&gt;=4.0" &#125;, //dependencies字段指定了项目运行所依赖的模块，devDependencies指定项目开发所需要的模块。 //指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。 //波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。 //插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。 //latest：安装最新版本。 "dependencies": &#123; ...... &#125;, "devDependencies": &#123; ...... &#125;&#125; #生成配置文件 1$ npm init 这个命令采用互动方式，要求用户回答一些问题，然后在当前目录生成一个基本的package.json文件。所有问题之中，只有项目名称（name）和项目版本（version）是必填的，其他都是选填的。 #添加依赖 12$ npm install express --save$ npm install express --save-dev 上面代码表示单独安装express模块，--save参数表示将该模块写入dependencies属性，--save-dev表示将该模块写入devDependencies属性。 #Dependencies傻傻分不清 参考[2]: dependencies是运行项目必须安装的依赖。 devDependencies是参与再开发需要安装的依赖，相当于开发工具。 peerDependencies是为插件准备的。比如grunt的插件，里面没有equire(&quot;grunt&quot;)，所以用dependencies会有问题。所以需要单独列出。 #参考资料 package.json文件 ↩ nodejs 依赖关系定义 ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017主攻技术选型]]></title>
      <url>%2F2017%2F04%2F10%2F2017%E4%B8%BB%E6%94%BB%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[#技术选型 服务端：通过DingoApi插件把Laravel作为Restful API框架使用 前端：VueJs通过官方推荐的axios插件调用服务端API 平台： 原生：使用阿里维护并且刚刚和VueJs作者深度合作的Weex框架导出原生应用 浏览器：通过TalkingData维护的IView UI组件渲染网页，通过Webpack打包发布浏览器版本 #自问自答 #为什么选VueJs前端MVVM框架 因为它支持原生平台，因为它比ReactJs轻，因为它的学习曲线没ReactJs陡峭，因为入门半个月了，前面的是瞎扯，因为它ICON的主页都是绿色的！就是那么任性 #为什么选Laravel做后端 因为对PHP相对比较熟悉，Laravel框架也使用过，同时找到一款可以把Laravel转化为Restful API的插件Dingoapi, VueJs也有axios插件这段官方推荐的ajax插件，这样就降低了学习成本，能比较平滑的用到生产环境中，毕竟对服务器渲染还不是很习惯。等项目稳定了，会逐步把Laravel把生产环境中剥离替换成NodeJs的Express，能发挥出vue-server特色 #为什么选择Webpack打包Web端 因为Vue初始化的配置就是使用webpack的，对它支持的会比较好。不需要特别去折腾配置的事情 #Weex和HBuilder的选择 本来是没什么好犹豫的，VueJs作者已经和Weex深度合作了。但鉴于Weex的Demo UI丑到一定境界了，同时又看到了这篇文章[1]，还有这个案列[2]。我又开始纠结这个选型了。不过还是给Weex一个机会吧。如果Weex实在无法忍就选择mui这个备胎 #为什么使用IView作为Web UI框架 因为它由中国最大的大数据平台TalkingData维护的一个UI项目，我一直很喜欢TalkingData的简洁的方格，这个UI框架的存在也让我很庆幸选择了VueJs作为前端技术栈 #技术官网 Laravel Dingoapi axios VueJs IView Webpack Weex ECMAScript 6 入门 NodeJs 包教不包会 #参考资料 H5移动前端框架之Avalon+MUI教程：一、技术选型 ↩ vue-html5plus ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Protobuf安装与入门]]></title>
      <url>%2F2017%2F04%2F08%2FProtobuf%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[#MAC下安装 #安装必要工具(如果没安装) 12brew install autoconf automake libtool curl make g++ unzip #安装Protobuf 1234567891011121314git clone https://github.com/google/protobuf.git./autogen.sh./configuremakemake checkmake install#MAC下不需要调用#ldconfig Mac下不需要调用ldconfig[1] #HelloWorld C++ #编写协议 1234567891011#创建需要的目录mkdir testcd testmkdir protosmkdir cccd protos#编辑协议文件vim addressbook.proto#编译协议到../cc文件夹protoc --cpp_out=../cc addressbook.proto addressbook.proto 123456789101112syntax = "proto2"package tutorial;message Person &#123; required string name = 1; required int32 age = 2;&#125;message AddressBook &#123; repeated Person person = 1;&#125; #编写测试代码 123456789#编写测试代码cd ../ccvim write.cppvim read.cpp#编译测试代码g++ addressbook.pb.cc write.cpp -o write `pkg-config --cflags --libs protobuf`g++ addressbook.pb.cc read.cpp -o read `pkg-config --cflags --libs protobuf` write.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include "addressbook.pb.h"using namespace std;void PromptForAddress(tutorial::Person *person) &#123; cout &lt;&lt; "Enter person name:" &lt;&lt; endl; string name; cin &gt;&gt; name; person-&gt;set_name(name); int age; cin &gt;&gt; age; person-&gt;set_age(age);&#125;int main(int argc, char **argv) &#123; //GOOGLE_PROTOBUF_VERIFY_VERSION; if (argc != 2) &#123; cerr &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " ADDRESS_BOOL_FILE" &lt;&lt; endl; return -1; &#125; tutorial::AddressBook address_book; &#123; fstream input(argv[1], ios::in | ios::binary); if (!input) &#123; cout &lt;&lt; argv[1] &lt;&lt; ": File not found. Creating a new file." &lt;&lt; endl; &#125; else if (!address_book.ParseFromIstream(&amp;input)) &#123; cerr &lt;&lt; "Filed to parse address book." &lt;&lt; endl; return -1; &#125; &#125; // Add an address PromptForAddress(address_book.add_person()); &#123; fstream output(argv[1], ios::out | ios::trunc | ios::binary); if (!address_book.SerializeToOstream(&amp;output)) &#123; cerr &lt;&lt; "Failed to write address book." &lt;&lt; endl; return -1; &#125; &#125; // Optional: Delete all global objects allocated by libprotobuf. //google::protobuf::ShutdownProtobufLibrary(); return 0;&#125; read.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include "addressbook.pb.h"using namespace std;void ListPeople(const tutorial::AddressBook&amp; address_book) &#123; for (int i = 0; i &lt; address_book.person_size(); i++) &#123; const tutorial::Person&amp; person = address_book.person(i); cout &lt;&lt; person.name() &lt;&lt; " " &lt;&lt; person.age() &lt;&lt; endl; &#125;&#125;int main(int argc, char **argv) &#123; //GOOGLE_PROTOBUF_VERIFY_VERSION; if (argc != 2) &#123; cerr &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " ADDRESS_BOOL_FILE" &lt;&lt; endl; return -1; &#125; tutorial::AddressBook address_book; &#123; fstream input(argv[1], ios::in | ios::binary); if (!address_book.ParseFromIstream(&amp;input)) &#123; cerr &lt;&lt; "Filed to parse address book." &lt;&lt; endl; return -1; &#125; input.close(); &#125; ListPeople(address_book); // Optional: Delete all global objects allocated by libprotobuf. //google::protobuf::ShutdownProtobufLibrary(); return 0;&#125; #测试结果 123456./write file&gt;&gt;file: File not found. Creating a new file.&gt;&gt;Enter person name:&gt;&gt;loostudy 18./read file&gt;&gt;loostudy 18 #总结 陌生代码块 123456789101112131415161718cin &gt;&gt; name; //输入结果遇到 Enter、Space、Tab 被截断fstream input(argv[1], ios::in | ios::binary); //输入流fstream output(argv[1], ios::out | ios::trunc | ios::binary); //输出流tutorial::AddressBook address_book; //声明协议address_book.ParseFromIstream(&amp;input) //解析协议address_book.SerializeToOstream(&amp;output) //序列化洗衣address_book.add_person() //添加repeated元素，返回Person指针，可对Person做修改person-&gt;set_name(name); //设置变量person.name(); //获取变量 到此入门安装测试已完成，目前对Protobuf的理解就是，通过一个.proto文件定义，协议格式，这份协议可以通过命令行protoc编译成不同语言对象格式。可以跨语言调用。 关于Protobuf的语法，和类库的引入(测试代码中是通过pkg-config --cflags --libs protobuf引入的，目前不太理解原理)以及protobuf2和protobuf3的区别做进一步研究整理。 #参考资料 google protobuf安装与使用 sudo: ldconfig: command not found for C++ installation on Mac OS X, Sierra ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Next主题净化主页]]></title>
      <url>%2F2017%2F04%2F07%2FNext%E4%B8%BB%E9%A2%98%E5%87%80%E5%8C%96%E4%B8%BB%E9%A1%B5%2F</url>
      <content type="text"><![CDATA[#前言 Next默认主题主页导航内容有些啰嗦，而且时常会因为&lt;!-- more --&gt;出BUG导致排版很难看。所以决定把主页净化一下。 主页的作用很简单，就是只要显示标题，时间，类型就可以了。来看看净化前的效果 #优化 打开themes/next/layout/_macro/post.swig 注释掉选中内容 123456&#123;% if is_index %&#125; &#123;# ReadMore 内容显示 &#123;% if post.description and theme.excerpt_description %&#125; &#123;% endif %&#125; #&#125;&#123;% else %&#125; 打开themes/next/source/css/_schemes/Mist/_posts-expanded.styl，修改样式 12//.post &#123; margin-top: 120px; &#125;.post &#123; margin-top: 0px; font-family: Chunkfive; src: url('Chunkfive.otf');&#125; 我用的是Mist样式。其他样式可以找对应样式目录 #优化后 明显导航干净很多，突出重点！ 注： 有其他需要修改的内容，可以在post.swig内搜索is_index参数，这个参数表示是导航页]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cocos2dx网络编程Socket]]></title>
      <url>%2F2017%2F04%2F06%2FCocos2dx%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BSocket%2F</url>
      <content type="text"><![CDATA[#[ProtoBuf][1] 待整理 #参考资料 cocos2dx_socket_example 1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cocos2dx预编译与模板]]></title>
      <url>%2F2017%2F04%2F06%2FCocos2dx%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[一条命令创建预编译洁净Cocos2dx工程 #前言 新建的Cocos2dx工程第一次编译至少十分钟，打包Android工程又需要再花十分钟左右再编译一次。每次新建项目都要再次把这些时间浪费在编译上。 当你想发布版本到Appstore,你需要Archive。有无限提交失败经验的人应该知道那是有多崩溃。 想要给游戏添加网上开源的模块，但又不确定可行性。最理想的方式就是应该建一个新项目，克隆代码，测试功能，然后再用到生产环境中。但新项目的编译阴影要么让我放弃了好模块的引入，要么就是直接引入造成一系列BUG！ 受到这个帖子[1]的启发 我决定拔掉这根刺了！ 找了些资料自己做了下尝试，准备从模板，预编译，相关配置，解决这些烦恼。 想要达到的效果是cocos new project_name -p package -l cpp -t template这一条命令就完成所有需要的配置，之后的开发只需要关心业务需求。不需要额外配置，无论ios还是android都是可以10秒内完成编译 #预编译类库 修改Android以下项目配置文件，修改目标安卓版本到你已安装的版本[2] 预编译目标项目： cocos2d-x-3.13.1\tools\simulator\frameworks\runtime-src\proj.android\project.properties cocos2d-x-3.13.1\cocos\platform\android\java\project.properties 1target=android-19 注意！ ANDROID_SDK_ROOT环境变量cocos2dx只认bash的，也就是无论你使用哪个shell,都必须保证~/.bash_profile文件内配置的环境变量正确，否则会找不到SDK 如果以前预编译过，请删除cocos2d-x-3.13.1\tools\simulator\frameworks\runtime-src\proj.android\obj目录再重新编译 使用gen-libs命令预编译类库[3],编译完的类库在$(COCOS2DX_ROOT)/prebuilt,这里不能用-m debug，原因见[4] 1cocos gen-libs -p ios -p android 使用lipo命令查看静态链接库a支持的构架 12345lipo -info /Usashers/bill/sdks/Cocos2d-x/cocos2d-x-3.13.1/prebuilt/ios/libcocos2d\ iOS.a#-m debug不支持x86_64 arm64 无法跑模拟器和真机Architectures in the fat file: /Users/bill/sdks/Cocos2d-x/cocos2d-x-3.13.1/prebuilt/ios/libcocos2d iOS.a are: i386 armv7#不添加-m debugArchitectures in the fat file: /Users/bill/sdks/Cocos2d-x/cocos2d-x-3.13.1/prebuilt/ios/libcocos2d iOS.a are: i386 armv7 x86_64 arm64 #自定义模板 #删除不需要的目录 在$(COCOS2DX_ROOT)/template复制份cpp-template-default模板，改名为cpp-template-prebuilt 由于我只需要ios和android,所以我可以删除其他目录，然后修改模板配置cocos-project-template.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; "do_default":&#123; "project_rename":&#123; "src_project_name":"HelloCpp", "files":[ "proj.ios_mac/PROJECT_NAME.xcodeproj" ] &#125;, "project_replace_project_name":&#123; "src_project_name":"HelloCpp", "files":[ "Classes/AppDelegate.cpp", "proj.android-studio/settings.gradle", "proj.android-studio/app/res/values/strings.xml", "proj.ios_mac/ios/main.m", "proj.ios_mac/ios/Prefix.pch", "proj.ios_mac/PROJECT_NAME.xcodeproj/project.pbxproj" ] &#125;, "project_replace_package_name":&#123; "src_package_name":"org.cocos2dx.hellocpp", "files":[ "proj.android-studio/app/build.gradle", "proj.android-studio/app/AndroidManifest.xml" ] &#125;, "project_replace_ios_bundleid": &#123; "src_bundle_id": "org.cocos2dx.hellocpp", "files": [ "proj.ios_mac/ios/Info.plist" ] &#125; &#125;, "change_orientation": &#123; "modify_files": [ &#123; "file_path": "Classes/AppDelegate.cpp", "pattern": "static\\s+cocos2d\\:\\:Size\\s+([a-zA-Z_\\d]+)\\s*=\\s*cocos2d\\:\\:Size\\(\\s*(\\d+),\\s*(\\d+)\\)", "replace_string": "static cocos2d::Size \\1 = cocos2d::Size(\\3, \\2)" &#125;, &#123; "file_path": "proj.ios_mac/ios/Info.plist", "pattern": "UIInterfaceOrientationLandscapeRight", "replace_string": "UIInterfaceOrientationPortrait" &#125;, &#123; "file_path": "proj.ios_mac/ios/Info.plist", "pattern": "UIInterfaceOrientationLandscapeLeft", "replace_string": "UIInterfaceOrientationPortraitUpsideDown" &#125;, &#123; "file_path": "proj.android-studio/app/AndroidManifest.xml", "pattern": "android:screenOrientation=\\\".*\\\"", "replace_string": "android:screenOrientation=\"portrait\"" &#125; ] &#125;&#125; #添加.gitignore 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# Created by .ignore support plugin (hsz.mobi)### cocos2dx template### C++ template# Prerequisites*.d# Compiled Object files*.slo*.lo*.o*.obj# Precompiled Headers*.gch*.pch# Compiled Dynamic libraries*.so*.dylib*.dll# Fortran module files*.mod*.smod# Compiled Static libraries*.lai*.la*.a*.lib# Executables*.exe*.out*.app### Xcode template# Xcode## gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore## Build generatedbuild/DerivedData/## Various settings*.pbxuser!default.pbxuser*.mode1v3!default.mode1v3*.mode2v3!default.mode2v3*.perspectivev3!default.perspectivev3xcuserdata/## Other*.moved-aside*.xccheckout*.xcscmblueprint #模板项目配置 #Xcode 导入libcocos2d IOS.a静态链接库 参考[5]添加Xcode自定义COCOS2DX_ROOT变量 参考[6]配置Header Search Paths 配置Library Search Paths #Android Studio #Gradle配置 编辑gradle/wrapper/gradle-wrapper.properties,修改下面行 1https\://services.gradle.org/distributions/gradle-2.14.1-all.zip 编辑build.gradle 1234567buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; // classpath 'com.android.tools.build:gradle:1.3.0' classpath 'com.android.tools.build:gradle:2.2.3' #编辑Android.mk[7] 1234567#$(call import-add-path,$(LOCAL_PATH)/../../../cocos2d)#$(call import-add-path,$(LOCAL_PATH)/../../../cocos2d/external)#$(call import-add-path,$(LOCAL_PATH)/../../../cocos2d/cocos)#$(call import-add-path,$(LOCAL_PATH)/../../../cocos2d/cocos/audio/include)#$(call import-module,.)$(call import-module,./prebuilt-mk) #编辑build-cfg.json[7] 1234567891011121314&#123; "ndk_module_path" :[ "/Users/bill/sdks/Cocos2d-x/cocos2d-x-3.13.1", "/Users/bill/sdks/Cocos2d-x/cocos2d-x-3.13.1/cocos/prebuilt-mk", "/Users/bill/sdks/Cocos2d-x/cocos2d-x-3.13.1/cocos", "/Users/bill/sdks/Cocos2d-x/cocos2d-x-3.13.1/external" ], "copy_resources": [ &#123; "from": "../Resources", "to": "" &#125; ]&#125; #编辑prebuilt-mk 编辑$(COCOS2DX_ROOT)/cocos/prebuilt-mk/Android.mk,参考[8] 1# $(call import-module, android/cpufeatures/prebuilt-mk) #添加cocos2dx类库 把$(COCOS2DX_ROOT)/cocos/platform/android/下对应文件拷贝到模板对应目录 #新建模板项目 1cocos new SocketDemo -p my.first.prebuilt -l cpp -t prebuilt 生成包体大小5.4M，开箱即用，编译IOS版 6秒。安卓版慢一点，要1分钟左右。我看LOG是还在编译一些类库。不过这已经是质的飞跃了！ 以后找网上的好代码，直接建个新工程测试就可以了！ #遗留问题 用我的模板生成的工程Schemes名字没有替换成我工程的名字（默认模板是可以的），无法直接运行，需要进Edit Scheme，选择Executable。然后就可以运行 解决办法 找到$(COCOS2DX_ROOT)/templates/cpp-template-prebuilt/HelloCpp.xcodeproj，右键显示包内容，删除xcuserdata文件夹，一切OK! #参考资料 cocos2d-x-3.13.1版本预编译库的使用 ↩ –ap in cocos gen-libs didn’t work. ↩ cocos gen-libs文档 ↩ cocos gen-libs -m debug 只支持i386 armv7 ↩ Xcode设置自定义Build Setting ↩ xcode路径配置 ↩ How to speed up cocos2d-x build with prebuilt lib ↩ ↩ Cannot find module with tag ‘android/cpufeatures/prebuilt-mk’ ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo版本维护]]></title>
      <url>%2F2017%2F04%2F05%2FHexo%E7%89%88%E6%9C%AC%E7%BB%B4%E6%8A%A4%2F</url>
      <content type="text"><![CDATA[维护Hexo项目的版本以及如何在新环境继续复刻版本 #前言 hexo部署只是把public内生成的静态文件提交到page仓库，但md文件、配置文件、主题文件并没有维护版本。 为了应对意外情况以及在新环境下依旧可以更新博客，需要把这些内容的版本维护起来 #版本维护[1] 用Coding仓库的分支hexo来维护版本,这样不会污染作为page展示的master分支内容 1234567cd 项目根目录git initgit remote coding 你的仓库地址.gitgit add .git common -m '提交描述'git branch hexo #创建分支git push coding hexo #提交到分支 #新机器获取版本 123git clone 你的仓库地址.gitgit checkout hexonpm install 然后就可以开始写作和部署了 注意：在新机器上需要自己先部署好nodejs,npm,hexo环境！ #参考资料 在不同的电脑维护Hexo和写作 ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo图床]]></title>
      <url>%2F2017%2F04%2F05%2FHexo%E5%9B%BE%E5%BA%8A%2F</url>
      <content type="text"><![CDATA[七牛静态资源同步插件hexo-qiniu-sync安装配置 #安装插件[1] 1npm install hexo-qiniu-sync --save #获取七牛的AK和SK 参考网页[2]，如到七牛后台的如下入口获取密钥 #配置插件 参考网页[3]配置根目录_config.yml 12345678910111213141516171819202122232425# 七牛同步qiniu: offline: false sync: true bucket: bucket name #secret_file: sec/qn.json or C: access_key: your ak secret_key: your sk #bucket静态资源存放目录 dirPrefix: static #给url添加的前缀，格式 七牛分配的域名+dirPrefix urlPrefix: your-url/static #图片上传url，默认即可 up_host: http://upload.qiniu.com #本地静态资源存放目录 local_dir: static update_exist: true #资源目录配置 image: folder: images extend: js: folder: js css: folder: css #初始化静态资源路径 运行hexo g命令可以根据配置初始化必要的存放资源路径，只要把需要同步的图片资源放到static/images里就可以了 #使用七牛图片 在文章中需要用到图片的位置插入 1&#123;% qnimg qiniu-logo.png title:七牛云 logo alt:七牛云 'class:' extend:?imageView2/2/w/550 %&#125; #同步图片到七牛 hexo s和hexo qiniu sync|sync2都可以同步图片 #CDN资源缓存问题解决 #添加? v= 用户在开发中，需要更新图片， css，html 等静态资源。而且在七牛是同名资源覆盖，这就导致文件在七牛源站更新后，却取的是 cdn 的旧缓存。所以用户可以每次更新文件的时候，在自己网站发布时候，对资源做? v=… 的版本替换。这样就可以保证更新后访问的是新的了。 #云储存上刷新 #参考资料 hexo-qiniu-sync官网 ↩ 如何获取七牛云存储的AccessKey和SecretKey ↩ 七牛同步插件使用 ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo写作必备]]></title>
      <url>%2F2017%2F04%2F05%2FHexo%E5%86%99%E4%BD%9C%E5%BF%85%E5%A4%87%2F</url>
      <content type="text"><![CDATA[HexoAdmin安装部署，和Hexo内置标签整理 #HexoAdmin[1] HexoAdmin是一个可视化编辑，管理和部署Hexo博客的后台插件。 #安装 在hexo项目根目录安装 1➜ hexo-site npm install --save hexo-admin #运行 1➜ hexo-site hexo s 在浏览器打开 http://localhost:4000/admin/ 主界面 账户密码设置界面 #写作 这里没什么可说的，点击New Post之后就可以可视化编辑了。 值得一提的是，添加图片的时候不是拖拽，是复制粘贴 复制粘贴 复制粘贴！！！ #部署 1touch hexo-deploy.sh; chmod a+x hexo-deploy.sh 在hexo-deploy.sh内添加两行，参考https://github.com/vladpurga/hexo-admin-deploy-command 12#!/usr/bin/env shhexo deploy 编辑_config.yml 12admin: deployCommand: './hexo-deploy.sh' 按说明操作部署就OK了！ 在部署过程中遇到一个很诡异的问题： 指定hexo d命令报错： fatal: unable to access 'https://git.coding.net/loostudy/loostudy.coding.me.git/': The requested URL returned error: 500 但是仓库的确是存在可用的，找了半天原因，最后我把在根目录的.git文件夹删掉就一切正常了！之后git init重新初始化版本维护依旧正常，不知道什么原因。 #Next内置标签[2] #文本居中引用 12345&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;居中引用&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; 居中引用 &#123;% endcq %&#125; 效果 居中引用 #笔记框note 12#可选class name &gt; default primary success info warning danger&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 效果 default primary success warning info danger #Hexo内置标签[3] #插入图片 Markdown格式插入图片无法修改大小，而且Hexo不支持Markdown的title，需要修改带下和增加title需要使用内放标签 1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; #引用自己的文章 123&#123;% post_link post文件名 别名 %&#125;比如&#123;% post_link Hexo建站宝典 宝典！%&#125; 宝典！ #hexo-renderer-markdown-it插件[4] #安装插件 12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save #配置_config.yml 123456789101112131415161718192021222324# Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki/markdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: '“”‘’' plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup #自动生成永久链接标记，鼠标点击标题后面的permalinkSymbol符号，会调转到新的固定链接。 #使用这个链接可以直接跳转到这个标题位置 anchors: level: 2 collisionSuffix: 'v' permalink: true permalinkClass: header-anchor permalinkSymbol: '#' #默认标示太难看，改成#号 #永久链接 配置anchors属性可以给每个标题添加永久链接 点击这个标记会生成形如这样的链接 http://localhost:4000/2017/04/05/Hexo%E5%BB%BA%E7%AB%99%E5%AE%9D%E5%85%B8/#进阶 使用这个链接可以直接跳转到这个标题 #添加注脚 12内容[^1][^1]: 这里是注脚 #[BUG]内置more标签失效 参照网页[5]解决插件本身造成的BUG。如果已经无效的话，请确认&lt;!-- more --&gt;上下行时候有空格，一定要空格隔开，要不也会失效 1234缩略描述 //缩略描述也是必须的//空格是必须的&lt;!-- more --&gt;//空格是必须的 #参考资料 Hexo-Admin主页 ↩ Next内置标签 ↩ Hexo内置标签 ↩ use-hexo-renderer-markdown-it ↩ Hexo + Markdown issues ↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo建站宝典]]></title>
      <url>%2F2017%2F04%2F05%2FHexo%E5%BB%BA%E7%AB%99%E5%AE%9D%E5%85%B8%2F</url>
      <content type="text"><![CDATA[Hexo从零开始到Coding部署个人博客 #Hexo安装配置 #安装Hexo 1$ npm install -g hexo-cli #新建站点文件 1$ hexo init &lt;foldname&gt; #创建新post 1$ hexo n 'name' #更新 1$ hexo g #清理 1$ hexo clean #每次发布前建议清理下，尤其是在更改样式和脚本的时候，会有缓存 #本地服务器 1$ hexo s #Next主题安装配置 #下载 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next #站点配置 站点目录下的_config.yml文件 123456789101112131415#站点标题title: LOOSTUDY#站点小标题subtitle: 绽放时厚积薄发 等待时心如止水#站点描述description: 绽放时厚积薄发 等待时心如止水#作者名author: loostudy#选择语言简体中文language: zh-Hans...#选择主题nexttheme: next #主题配置 站点目录下的\themes\next\_config.yml文件 1234567#修改scheme#scheme: Musescheme: Mist#scheme: Pisces#修改代码高亮主题 可选值 normal，night， night blue， night bright， night eightieshighlight_theme: night bright #进阶 #修改post模板 打开scaffolds\post.md 1234567---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;#添加分类categories:tags:--- #标签和分类[1] #修改文章md内的分类 1categories: 编程 #映射文件夹，修改站点目录下的_config.yml文件 123456default_category: uncategorizedcategory_map: 编程: programming 生活: life 其他: othertag_map: #文章多标签使用 1tages: [标签1,标签2,...标签n] #Next标签[2]分类[3]页面 #新建 1234#新建标签页$ hexo new page tags#新建分类页$ hexo new page categories #修改标签分类页面内容 12345title: 标签date: 2014-12-22 12:39:04type: "tags"comments: false--- 12345title: 分类date: 2014-12-22 12:39:04type: "categories"comments: false--- #Next主页导航优化[4] #more标签 在文章title后面添加&lt;!-- more --&gt;标签 12345678---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:---简单说明&lt;!-- more --&gt; #部署到Codiing #安装hexo-deployer-git 1$ npm install hexo-deployer-git --save #修改配置 这里一定要用master分支，coding-pages分支测试无效 1234deploy: type: git repo: coding: https://git.coding.net/loostudy/loostudy.coding.me.git,master #绑定证书 生成证书 1ssh-keygen -t rsa -C "邮箱" 把证书的公钥(~/.ssh/id_rsa.pub)的内容拷贝到coding个人账户下的SSH公钥里面 #部署 由于coding的Pages服务是默认执行jekyll项目, 静态项目需要一个.nojekyll文件标识. 所以第一次执行, 需要在生成的public文件夹中加入一个 .nojekyll 空白文件 1hexo d #Hexo修改文件夹大小写问题 当你想把catagory或者tag修改大小写的时候，你重新部署会发现，上传到服务器的文件夹大小写没变，导致请求改tag和catagory URL的时候显示404。要解决这个问题要做一下两步：[5] 删除.deploy_git目录 再次运行hexo d提交，hexo会重置git仓库，并重新生成所有文件! 可以使用下面语句设置git大小写敏感，防止下次出现这样的问题： 12git config core.ignorecase false #参考资料 Hexo使用攻略：（四）Hexo的分类和标签设置 ↩ Next添加标签页面 ↩ Next添加分类页面 ↩ 如何实现首页文章,只显示标题而不是全文 ↩ Hexo部署到Github上文件夹的大小写问题 ↩]]></content>
    </entry>

    
  
  
</search>
